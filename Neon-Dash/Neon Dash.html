<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Dash: Kontrol Seçimi</title>
    <style>
        body { margin: 0; background: #050005; overflow: hidden; font-family: 'Courier New', monospace; color: #fff; }
        canvas { display: none; } /* Seçim yapılana kadar gizli */
        
        /* Seçim Ekranı Tasarımı */
        #lobby {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            height: 100vh; text-align: center; background: radial-gradient(circle, #1a001a 0%, #000 100%);
        }
        h1 { font-size: 3em; color: #00f2ff; text-shadow: 0 0 20px #00f2ff; margin-bottom: 50px; }
        .btn-container { display: flex; gap: 30px; flex-wrap: wrap; justify-content: center; }
        .mode-btn {
            padding: 20px 40px; font-size: 20px; font-weight: bold; cursor: pointer;
            border: 3px solid #ff00ff; background: transparent; color: #ff00ff;
            text-transform: uppercase; transition: 0.3s; border-radius: 10px;
        }
        .mode-btn:hover { background: #ff00ff; color: #000; box-shadow: 0 0 30px #ff00ff; }

        /* Oyun UI */
        #ui-layer {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; flex-direction: column; align-items: center;
        }
        #progress-wrap { width: 40%; height: 6px; background: rgba(255,255,255,0.1); margin-top: 40px; border-radius: 10px; overflow: hidden; border: 1px solid #ff00ff; }
        #progress-fill { width: 0%; height: 100%; background: linear-gradient(90deg, #ff00ff, #00f2ff); box-shadow: 0 0 15px #ff00ff; }
        #jump-count { color: #00f2ff; font-size: 18px; margin-top: 10px; text-shadow: 0 0 10px #00f2ff; font-weight: bold; }
    </style>
</head>
<body>

    <div id="lobby">
        <h1>NEON DASH</h1>
        <div class="btn-container">
            <button class="mode-btn" onclick="startGame('mobile')">DOKUNMATİK</button>
            <button class="mode-btn" onclick="startGame('pc')">KLAVYE / PC</button>
        </div>
        <p style="margin-top: 20px; color: #888;">Lütfen cihazınıza uygun modu seçin</p>
    </div>

    <div id="ui-layer">
        <div id="progress-wrap"><div id="progress-fill"></div></div>
        <div id="jump-count">ENERJİ: |||</div>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const lobby = document.getElementById('lobby');
        const uiLayer = document.getElementById('ui-layer');
        const progressFill = document.getElementById('progress-fill');
        const jumpText = document.getElementById('jump-count');

        let controlMode = 'pc';
        let gameActive = false;

        function startGame(mode) {
            controlMode = mode;
            lobby.style.display = 'none';
            canvas.style.display = 'block';
            uiLayer.style.display = 'flex';
            gameActive = true;
            resize();
            animate();
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);

        // --- OYUN PARAMETRELERİ ---
        const levelData = "  s  s  d  s  t  s  d  d  s  t   s   d  s  s  t  s  d  s  t  s  d  s s d d t t end";
        const map = levelData.split("");
        const spacing = 450; 
        const randomBlocks = [];
        let scrollX = 0;
        const gravity = 0.7;
        const jumpForce = -14;
        const speed = 9;

        // Rastgele Bloklar
        for(let i = 0; i < map.length; i++) {
            if(Math.random() > 0.6) {
                randomBlocks.push({ x: (i * spacing) + 1000 + (Math.random() * 200), y: window.innerHeight - 250 - (Math.random() * 100), w: 80, h: 20 });
            }
        }

        const player = {
            x: 200, y: 0, size: 40, dy: 0, rotation: 0, grounded: false, jumpsLeft: 3,
            update() {
                this.dy += gravity;
                this.y += this.dy;
                const groundY = canvas.height - 150;
                
                if (this.y + this.size > groundY) { this.land(groundY - this.size); } 
                else { this.grounded = false; this.rotation += 7; }

                randomBlocks.forEach(block => {
                    let xPos = block.x - scrollX;
                    if (this.x + this.size > xPos && this.x < xPos + block.w && this.dy > 0 && this.y + this.size > block.y && this.y + this.size < block.y + block.h + 20) {
                        this.land(block.y - this.size);
                    }
                });
                jumpText.innerText = "ENERJİ: " + "|".repeat(this.jumpsLeft);
            },
            land(newY) { this.y = newY; this.dy = 0; this.grounded = true; this.jumpsLeft = 3; this.rotation = Math.round(this.rotation / 90) * 90; },
            jump() { if (this.jumpsLeft > 0) { this.dy = jumpForce; this.jumpsLeft--; this.grounded = false; } }
        };

        // --- KONTROL ATAMALARI ---
        window.addEventListener('keydown', e => { if (controlMode === 'pc' && (e.code === 'Space' || e.code === 'ArrowUp')) player.jump(); });
        window.addEventListener('mousedown', () => { if (controlMode === 'pc') player.jump(); });
        window.addEventListener('touchstart', (e) => { if (controlMode === 'mobile') { e.preventDefault(); player.jump(); } }, {passive: false});

        function drawWorld() {
            const groundY = canvas.height - 150;
            ctx.strokeStyle = "rgba(255, 0, 255, 0.05)";
            for(let i = 0; i < canvas.width; i += 50) { ctx.beginPath(); ctx.moveTo(i - (scrollX % 50), 0); ctx.lineTo(i - (scrollX % 50), canvas.height); ctx.stroke(); }
            ctx.shadowBlur = 15; ctx.shadowColor = "#ff00ff"; ctx.strokeStyle = "#ff00ff"; ctx.lineWidth = 4;
            ctx.beginPath(); ctx.moveTo(0, groundY); ctx.lineTo(canvas.width, groundY); ctx.stroke();
            randomBlocks.forEach(block => {
                let xPos = block.x - scrollX;
                ctx.shadowBlur = 10; ctx.shadowColor = "#00f2ff"; ctx.strokeStyle = "#00f2ff";
                ctx.strokeRect(xPos, block.y, block.w, block.h);
                ctx.fillStyle = "rgba(0, 242, 255, 0.1)"; ctx.fillRect(xPos, block.y, block.w, block.h);
            });
        }

        function drawSpikes(x, type) {
            const groundY = canvas.height - 150;
            const drawS = (offset) => {
                ctx.shadowBlur = 20; ctx.shadowColor = "#ff00ff"; ctx.strokeStyle = "#ff00ff"; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.moveTo(x + offset, groundY); ctx.lineTo(x + offset + 25, groundY - 60); ctx.lineTo(x + offset + 50, groundY); ctx.closePath(); ctx.stroke();
                if (player.x + player.size > x + offset + 15 && player.x < x + offset + 35 && player.y + player.size > groundY - 50) gameOver();
            };
            if (type === 's') drawS(0);
            if (type === 'd') { drawS(0); drawS(60); }
            if (type === 't') { drawS(0); drawS(60); drawS(120); }
        }

        function gameOver() { gameActive = false; setTimeout(() => location.reload(), 500); }

        function animate() {
            if (!gameActive) return;
            ctx.fillStyle = "#050005"; ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawWorld();
            scrollX += speed;
            player.update();
            
            // Oyuncu Çizimi
            ctx.save();
            ctx.translate(player.x + player.size/2, player.y + player.size/2);
            ctx.rotate(player.rotation * Math.PI / 180);
            ctx.shadowBlur = 20; ctx.shadowColor = "#00f2ff"; ctx.strokeStyle = "#00f2ff"; ctx.lineWidth = 3;
            ctx.strokeRect(-player.size/2, -player.size/2, player.size, player.size);
            ctx.restore();

            map.forEach((char, i) => {
                let xPos = (i * spacing) - scrollX + 800;
                if (xPos > -200 && xPos < canvas.width + 200) drawSpikes(xPos, char);
            });

            progressFill.style.width = Math.min((scrollX / (map.length * spacing)) * 100, 100) + "%";
            requestAnimationFrame(animate);
        }
    </script>
</body>
</html>